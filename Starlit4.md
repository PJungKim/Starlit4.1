# Starlit 4 설명서

- Starlit 4 문법에 대한 문서
- Starlit 4는 다중 스타일 언어로 다양한 방식으로 작성하는 것이 가능한 언어이다.

## 1. Hello World 출력하기

- 프로그램의 시작은 언제나 그렇듯 `Hello, World!` 출력으로 시작한다. 왜인지는 모르지만 어쨌든 야무진 암묵적 룰인 듯하다.

### 1.1. 가장 간단한 코드

```Py
"Hello, World!"
```

- 가장 간단하게 `Hello World!`를 출력하는 코드이다. 아무 명령어 없이 큰따옴표만 잘 쓴다면 적절한 위치에 `Hello, World!`가 출력된다.

### 1.2. OLED에 Hello, World 출력하기(OLED 내장형 보드 한정)

```Py
OLED << "Hello, World!"
```

- 이번 출력은 OLED에 Hello, World를 출력하는 코드이다.
- 앞에서의 코드는 기본값으로 설정된 장치에서 출력되며, 이 코드는 OLED라는 특정 장치에서 출력된다는 차이가 있다. 만약 기본값으로 OLED에 출력되게 설정했다면 앞에서의 코드를 실행해도 OLED에 출력될 것이다.
- OLED가 있는 장치는 기본 OLED 객체에서 출력되고, Character LCD가 있는 장치는 LCD에 출력된다. LCD 출력은 경우에 따라 글자색 속성 설정이 제한될 수 있다.

### 1.3. PuTTY 창에 Hello, World 출력하기(FTDI/USB 통신 가능 보드 한정)

- PuTTY 창에 출력하는 경우 Serial 통신을 통해 출력하므로 FTDI 활성화 후 프린트 진행한다.
```Py
FTDI_Begin(115200)
PuTTY_cout << "Hello, World!"
```

### 1.4. `main` 함수 안에 Hello, World 출력하기

- 지금까지 코드는 구문으로만 작성하였으나, 일반적으로 함수 안에 코드를 작성하는 쪽을 권장한다.
- 함수 밖에 작성한 구문은 주로 초기화 코드를 의미한다. 이를테면 함수를 사용하여 변수를 초기화한다면 main 함수 실행되기 전에 우선 작동한다고 보면 된다.
```Py
main
    "Hello, World!"
```

### 1.5. `Pythonic`, 파이썬은 아니지만, 파이썬의 형식을 그대로 들여온 코드

- Starlit 4.1은 코드 표현의 자유를 최대한 존중하는 쪽으로 개발하였다.
- 다만, Starlit 4.1 작성 시 Python의 형태를 살려서 작성한다면 보기 매우 깔끔하기에 Python의 요소를 최대한 수용한 문법도 허용한다.
- 다음 코드는 모두 유효하다. 다만, def 키워드로 함수를 정의하지 않는다는 점에 유의하자.
```Py
main():
    "Hello, World!"
```
```Py
main:
    "Hello, World!"
```
```Py
main:
    f"Hello, World!"
```

### 1.6. `C-Style`, C언어의 스타일로 작성할 수도 있다.

- Starlit 2~3까지는 C언어의 스타일을 좀 더 엄격하게 적용한 스타일을 강제했다. 하지만, Starlit 1 이전에는 C언어의 스타일보다는 Python의 스타일 쪽에 더 가까웠다. 그래서 Starlit 4에서는 두 스타일 모두 수용하였다.
```C++
main(){
    "Hello, World!";
}
```
- 주의할 점은 C-Style로 코드를 작성하는 경우 세미콜론을 반드시 붙여야 한다는 점이다. 하지만, C-Style로 작성할 때는 들여쓰기 규칙을 지킬 필요가 없어진다.
- 원칙상 C-Style로 작성할 때는 C언어와 다르게 if문이나 for문에서는 단일 구문에 한해 중괄호를 생략하기도 했지만, Starlit에서는 단일 구문도 중괄호를 반드시 써야 한다. 이 특성상 C-Style로 작성할 때는 코드의 부피가 매우 커지는 이슈가 발생하기도 한다. 이를 해결하기 위한 방법은 뒤에서 자세히 설명한다.

### 1.7. `GUE-Style`, Starlit 1의 스타일을 최대한 보존한 형태

- Starlit 1의 장점과 단점을 분석해 보았다. 장점보다는 단점이 더 많았고, 프로그래밍 언어라 하기에는 데이터 구조 이슈가 있었지만, 장점도 분명히 있었다.
- Starlit 1의 장점이라면 Python의 들여쓰기 규칙이 적용되어 있었던 특성상 Starlit 2~3에 비해 코드의 부피가 늘지 않을 수 있다는 점이 있다. 하지만, 하나를 실행하기 위한 코드 수 자체가 많아 이런 장점이 제대로 실현되지 어려웠다.
- 따라서 Starlit 1의 장점만 살린 스타일로 아래와 같이 Hello, World 코드를 작성할 수 있다.
```Py
start>>
    Print OLED "Hello, World!"
```

### 1.8. 주석 처리는 코드에 있어서 매우 중요한 요소라고 본다.

- 코드가 복잡해질수록 그 코드가 어떤 역할을 하는지 명시해 놓는 것이 매우 중요하다. 따라서 주석 처리를 통해 코드를 설명해 주는 것이 좋다.
- Starlit 4는 코드의 자유도를 보장하는 만큼 주석 규칙이 다소 엄격한 특징이 있다.
  - C-Style 주석 : 한 줄 주석은 `///`로 시작하며, 구간 주석은 `/**`...`**/`로 끝난다.
  - Python-Style 주석 : 한 줄 주석은 `#`로 시작하며, 구간 주석은 개발 검토중이다.

```C++
main(){
    "Hello, World!"; /// Hello, World! 출력
}
```
```Py
main:
    f"Hello, World!" # Hello, World! 출력
```

- 개발환경에 맞게 주석 형태를 구성하면 된다.
  - C-Style로 개발하는 경우 개발 언어를 C/C++로 설정해놓고 `///` 주석을 사용한다.
  - Python-Style로 개발하는 경우 개발 언어를 Python으로 설정해 놓고 `#` 주석을 사용한다.

## 2. 간단한 연산 결과 출력하기

- 2장에서는 글자 서식 지정과 연산 결과 출력하는 예제를 중점으로 다루기로 한다.

### 2.1. 글자 색 지정

- 글자 색 지정은 PuTTY 화면, RGB 출력 가능한 OLED, RGB 출력 가능한 LCD를 대상으로 한다.
  - RGB 출력 불가능한 단색 문자 출력 LCD에는 이 기능 사용 불가
- 글자색 지정은 아래와 같이 Starlit 표준 규격을 정의하였다.
  |기호|글자색|기호|글자색|
  |--|--|--|--|
  |`/r`|빨강|`/o`|주황|
  |`/y`|노랑|`/l`|연두|
  |`/g`|초록|`/t`|에메랄드/민트|
  |`/c`|청록|`/s`|바다|
  |`/b`|파랑|`/v`|보라(Violet)|
  |`/m`|자홍|`/p`|장미/핑크|
  |`/w`|흰색|`/k`|검정색(흰 배경에서 출력 시 사용)|
- 다음과 같은 변형을 사용하기도 한다.
  - 연한 색은 대문자 사용 : `/r` ▷ `/R` : 연한 빨강색(분홍색)
  - 진한(어두운) 색은 d를 붙임 : `/r` ▷ `/dr` : 어두운 빨간색(적갈색)
  - 탁한 색은 d를 붙이고 대문자로 적는다. : `/r` ▷ `/dR` : 탁한 빨간색
- 글자색은 HEX CODE를 사용해 지정할 수 있다.
  - 빨간색 ▷ `/#FF0000`
  - 파란색 ▷ `/#0000FF`
- Hello는 빨간색, World는 노란색으로 출력하는 예제
  - 아래 코드는 모두 유효하다.
  - 다만, 기본 출력 장치가 RGB를 지원하지 않는다면 `OLED <<`와 같은 출력 함수를 써야 한다.
- Pythonic
```Py
main
    "/rHello, /yWorld!" # Hello는 빨간색으로, World는 노란색으로 출력
```
- GUE
```Py
start>>
    "/rHello, /yWorld!" # Hello는 빨간색으로, World는 노란색으로 출력
```
- C-Style(Starlit 2~3)
```C++
main(){
    "/rHello, /yWorld!"; /// Hello는 빨간색으로, World는 노란색으로 출력
}
```

### 2.2. 출력 위치 지정

- 임베디드 개발환경에서는 OLED나 LCD에 특정 위치에 출력을 반복해야 하는 상황이 자주 있다.
  - 예: 센서 값 출력, 위치나 속도 출력 등
- 특정 위치에 출력하기 위해서는 위치 표시 서식 문자를 사용한다.
- Starlit 표준 서식
  - Starlit은 가장 위에 있는 줄을 0번째 줄로 정의한 후 인덱싱한다.
  - `/0`~`/9` : 보통 크기의 Font에서 OLED, LCD, PuTTY 창 등에 0번째~9번째 줄에 출력한다.
- Starlit 확장 서식
  - Starlit은 기본적으로 임베디드 환경을 위해 설계해서 `/0`~`/9`만으로도 충분히 커버되는 상황이 대부분이었다.
  - 하지만, PuTTY 창 등과 같이 출력 범위가 큰 경우 이것만 가지고는 부족할 때도 있다.
  - 따라서 위치를 확장하기 위해서 `/[0]`, `/[1]`, ...와 같이 대괄호를 통해 위치를 표시할 수 있다.
  - 10진수와 16진수 사용안이 충돌하기도 하지만, 원칙적으로 10진수를 사용한다.
    - 16진수를 쓰면 알파벳이 포함되어 코드가 복잡해진다는 이유에서이다.
- 1초 간격으로 숫자를 증가해서 출력하는 예제
  - 아래 코드는 모두 유효하다.
  - 무한 반복을 위해 아래와 같이 `loop`를 돌린다(자세한 내용은 뒤에서 설명).
  - 숫자를 출력하기 위해 `f-문자열`을 사용한다.(자세한 내용은 뒤에서 설명)
- Pythonic
```Py
a = 0
loop
    f"/0/rValue=/y{a:4d}" # 변수 a값 출력
    Delay(1000)           # 1초 기다라기
    a += 1                # a값 1만큼 증가
```
- GUE
  - 변수 정의 방법이 상당히 특이하다. Starlit 1에서의 변수 대입 방식을 그대로 받아들였기 때문이다.
```Py
_a 0
loop>>
    f"/0/rValue=/y{a:4d}" # 변수 a값 출력
    Delay 1000            # 1초 기다라기
    _a a+1                # a값 1만큼 증가
```
- C-Style(Starlit 2~3)
  - C-Style이라고 해도 `f-문자열` 사용이 가능하고, `a = 0`만으로 변수 정의가 가능하다.
```C++
a = 0;
loop(){
    f"/0/rValue=/y{a:4d}"; /// 변수 a값 출력
    Delay(1000);           /// 1초 기다리기
    a += 1;                /// a값 1만큼 증가
}
```
- 지금까지 코드는 모두 같은 언어인 Starlit 4.1에 대응되는 코드이다. 단지 스타일이 크게 3가지로 나뉠 뿐이다. 이 스타일마저도 세세하게 나누면 수없이 다양한 형태의 코드로 쓸 수 있다.
- `f"/0/rValue=/y{a:4d}"`를 설명하자면, `/0`은 0번째 줄에 고정으로 출력하라는 의미이고, `/r`은 빨간색으로, `/y`는 노란색으로 출력하라는 의미이다. `""` 앞에 f를 붙여 f-string으로 출력함을 의미하고, `{}` 안에 a를 넣어 a를 출력한다. 이때, 뒤에 `:4d`는 4자리 출력(앞자리 공백으로 채움)을 의미한다.

### 2.3. 두 수의 합 간단하게 출력하는 예제

- 이번 시간에는 OLED <<와 OLED >>를 사용한 모델을 이용해 두 수를 입력받고 합을 출력해 보겠다. LCD 객체가 있다면 LCD <<, LCD >>를 쓰면 되지 않을까?
- Pythonic
```Py
a = 0
b = 0
main:
    "/ra값 입력: " >> OLED >> a << "\n" # "a값 입력" 문자열 출력 -> a 입력 -> 줄바꿈 출력
    "/gb값 입력: " >> OLED >> b << "\n"
    OLED << f"/y두 수의 합은 /c{a+b}/y입니다.\n" # 두 수의 합 출력
```
- GUE
```Py
_a 0
_b 0
start>>
    "/ra값 입력: " >> OLED >> a << "\n" # "a값 입력" 문자열 출력 -> a 입력 -> 줄바꿈 출력
    "/gb값 입력: " >> OLED >> b << "\n"
    OLED << f"/y두 수의 합은 /c{a+b}/y입니다.\n" # 두 수의 합 출력
```
- C-Style(Starlit 2~3)
```C++
a = 0;
b = 0;
main(){
    "/ra값 입력: " >> OLED >> a << "\n"; /// "a값 입력" 문자열 출력 -> a 입력 -> 줄바꿈 출력
    "/gb값 입력: " >> OLED >> b << "\n";
    OLED << f"/y두 수의 합은 /c{a+b}/y입니다.\n"; /// 두 수의 합 출력
}
```

### 2.4. 형식 지정

- Starlit에서는 형식 지정 방법을 2가지(`% Formatting`, `f-string`)로 제공한다.
- f-string(f-문자열)
  - 문자열 앞에 f를 붙인다고 해서 f-string이라고 부른다.
  - Python에서 공식적으로 지원하는 문법
  - 문자열 안에 {}를 추가하여 형식을 지정해서 출력할 수 있다.
  ```Py
  a = 20
  f"a = {a}" # "a = 20" 출력
  ```
- f-문자열의 주요 기능
  ```Py
  a = 20
  f"a = {a}" # "a = 20" 출력
  f"a = {a:4d}" # "a =   20" 출력, 공백 포함 4자리 맞춰서 출력
  f"{a=}" # "a=20" 출력
  f"a = {a:04d}" # "a = 0020" 출력, 3자리 이하는 앞에 0으로 채움
  ```
- % Formatting
  - `%d`, `%f`와 같은 형식 문자를 사용해 형식을 지정하는 방식
  - `Printf`라는 함수를 주로 사용한다.
  ```Py
  a = 20
  OLED.Printf("a = %d", a) # "a = 20" 출력
  OLED.Printf("a = %4d", a) # "a =   20" 출력
  OLED.Printf("a = %04d", a) # "a = 0020" 출력
  ```
- % Formatting 연산자
  - % Formatting 연산자를 사용해도 출력해볼 수 있다.
  - 주의할 점이라면 ""만 단독으로 사용하면 기본 출력 장치에 출력하지만, ""와 연산자를 같이 사용하면 기본 출력 장치에 출력되지 않아 출력 장치를 직접 설정해 주어야 한다.
  ```Py
  a = 20
  OLED << "a = %d" % a # "a = 20" 출력
  OLED << "a = %4d" % a # "a =   20" 출력
  OLED << "a = %04d" % a # "a = 0020" 출력
  ```

### 2.5. Starlit 연산자

- Starlit 연산자는 C의 연산자와 거의 비슷하다.
  - Python의 논리 연산자인 not, and, or은 사용하지 않는다.
  - C언어의 연산자 중 ++ 연산자와 ?: 연산자는 사용하지 않는다.
    - 앞에서의 코드 역시 같은 이유로 `a++`가 아닌 `a+=1`을 사용하였다.
  - Starlit은 포인터 개념을 사용하지 않아 포인터 연산자는 지원되지 않는다.
    |우선순위|연산자|기능|C/C++ 비교|Python 비교|연산자 오버로딩 함수|
    |---|---|---|---|---|---|
    |0|`()`, `[]`, `,`, `.`|괄호, 객체 지정|포인터 개념이 없어 `->` 미사용||오버로딩 미지원|
    |1|`:`|반복 연산자|미지원|용도가 다름|오버로딩 미지원|
  - (계속 작성 바랍니다.)

## 3. 조건문
- 3장에서는 `if`문과 `when`/`switch`문을 다룬다.

### 3.1. `if`문

- 조건이 참이면 실행하는 구문
- 예제 : 나눗셈 코드, 0이 아닌 수로 나눌 때만 나누기를 실행하는 코드
- 나머지가 0이 아닌 경우 나머지도 출력한다. **0이 아닐 때** 참으로 판단한다.
- Pythonic
```Py
a = 0
b = 0
main:
    "/r나누어지는 수: " >> OLED >> a << "\n"
    "/g나누는 수: " >> OLED >> b << "\n"
    if b != 0: # b가 0이 아닐 때 실행
        OLED << f"/c몫: {a / b}\n"
        if a % b: # 나머지가 0이 아닐 때 실행
            OLED << f"/m나머지: {a % b}\n"
```
- C-Style(Starlit 2~3)
```C++
a = 0;
b = 0;
main(){
    "/r나누어지는 수: " >> OLED >> a << "\n";
    "/g나누는 수: " >> OLED >> b << "\n";
    if(b != 0){ ///b가 0이 아닐 때 실행
        OLED << f"/c몫: {a / b}\n";
        if(a % b){ ///나머지가 0이 아닐 때 실행
            OLED << f"/m나머지: {a % b}\n";
        }
    }
}
```
- GUE
  - 사실상 Pythonic과 코드는 비슷하다.
  - 물론 엄밀한 GUE-Style로 넘어가면 Pythonic과 많이 달라진다. 하지만 여기서는 자세히 다루지 않고 따로 다룬다.
```Py
_a 0
_b 0
start>>
    "/r나누어지는 수: " >> OLED >> a << "\n"
    "/g나누는 수: " >> OLED >> b << "\n"
    if b != 0: # b가 0이 아닐 때 실행
        OLED << f"/c몫: {a / b}\n"
        if a % b: # 나머지가 0이 아닐 때 실행
            OLED << f"/m나머지: {a % b}\n"
```


### 3.2. `else`문

- 앞에서의 조건이 참이 아니면 실행하는 구문
- `else` 앞에는 `if`나 `elif`가 포함되어 있어야 한다.
- 앞에서의 예제에서 0으로 나눴을 때 오류가 발생했음을 알려주는 코드를 추가한 예제이다.
  - GUE-Style은 Pythonic과 유사하므로 따로 적지 않았다.
- Pythonic
```Py
a = 0
b = 0
main:
    "/r나누어지는 수: " >> OLED >> a << "\n"
    "/g나누는 수: " >> OLED >> b << "\n"
    if b != 0: # b가 0이 아닐 때 실행
        OLED << f"/c몫: {a / b}\n"
        if a % b: # 나머지가 0이 아닐 때 실행
            OLED << f"/m나머지: {a % b}\n"
    else:
        OLED << "0으로 나눌 수 없읍니다.\n"
```
- C-Style(Starlit 2~3)
```C++
a = 0;
b = 0;
main(){
    "/r나누어지는 수: " >> OLED >> a << "\n";
    "/g나누는 수: " >> OLED >> b << "\n";
    if(b != 0){ ///b가 0이 아닐 때 실행
        OLED << f"/c몫: {a / b}\n";
        if(a % b){ ///나머지가 0이 아닐 때 실행
            OLED << f"/m나머지: {a % b}\n";
        }
    }
    else{
        OLED << "0으로 나눌 수 없읍니다.\n"
    }
}
```
### 3.3. `elif`문
- C/C++에서는 `else if`라고 사용하지만, Starlit 언어는 중괄호 생략 법칙이 없는 특성상 `else if`에 해당하는 구문이 따로 존재하는데, 그것이 `elif`이다.
- 말 그대로 else 바로 뒤에 if가 붙는 구문이다.
- 다음 예제는 수를 입력해서 20과 1023 사이에 있는지 확인하는 코드이다.
- Pythonic
```Py
a = 0
main:
    "/r숫자 입력: " >> OLED >> a << "\n"
    if a > 1023:
        OLED << "/g1023보다 큽니다."
    elif a < 20:
        OLED << "/g20보다 작습니다."
    else:
        OLED << "/g20과 1023 사이에 있습니다."
```
- C-Style(Starlit 2~3)
```C++
a = 0
main(){
    "/r숫자 입력: " >> OLED >> a << "\n";
    if(a > 1023){
        OLED << "/g1023보다 큽니다.";
    }
    elif(a < 20){
        OLED << "/g20보다 작습니다.";
    }
    else{
        OLED << "/g20과 1023 사이에 있습니다.";
    }
}
```

### 3.4. 범위 안에 있는지 확인하는 코드

- 아래와 같이 `a <= b <= c`꼴로 쓰는 것도 유효한 코드이니 참고하자.
- Pythonic
```Py
a = 0
main:
    "/r숫자 입력: " >> OLED >> a << "\n"
    if 20 <= a <= 1023:
        OLED << "/g20과 1023 사이에 있읍니다."
    else:
        OLED << "/o20과 1023 사이에 없읍니다."
```
- C-Style(Starlit 2~3)
```C++
a = 0
main(){
    "/r숫자 입력: " >> OLED >> a << "\n";
    if(20 <= a <= 1023){
        OLED << "/g20과 1023 사이에 있읍니다.";
    }
    else{
        OLED << "/o20과 1023 사이에 없읍니다.";
    }
}
```

### 3.5. and 조건과 or 조건

- 2개의 조건을 동시에 만족해야 한다면 `&&` 연산자를 사용한다.
  - `20 <= a <= 1023`의 경우 `a >= 20 && a <= 1023`으로 나눌 수 있다.
    |AND(&&)|조건1이 참|조건1이 거짓|
    |---|---|---|
    |조건2가 참|참|거짓|
    |조건2가 거짓|거짓|거짓|
- 2개의 조건을 만족하지 않을 때 실행한다면 `!` 연산자를 사용한다.
  - `!(20 <= a <= 1023)`과 같이 명시하면 가의 범위인 19 이하와 1024 이상일 때 참으로 인식한다.
    |NOT(!)|조건1이 참|조건1이 거짓|
    |---|---|---|
    |결과|거짓|참|
- 2개의 조건 중 하나를 만족시킬 때는 `||` 연산자를 사용한다.
  - `1 <= a <= 10 || a >= 20`은 1~10까지 수 또는 20 이상의 수가 입력될 때 참이 된다.
    |OR(\|\|)|조건1이 참|조건1이 거짓|
    |---|---|---|
    |조건2가 참|참|참|
    |조건2가 거짓|참|거짓|

### 3.6 `when`문
- 값을 입력해서 특정 상황일 때만 실행하는 구문으로, C언어의 switch문과 유사하다.
- 아래 예제는 숫자를 고르면 거기에 맞는 색상을 출력하는 예제이다.
- Pythonic Style
```Py
main:
    a = int
    "0부터 9까지의 수 입력: " >> OLED >> a << "\n"
    when a:
        case 0:
            OLED << "/r빨강"
        case 1:
            OLED << "/o주황"
        case 2:
            OLED << "/y노랑"
        case 3:
            OLED << "/l연두"
        case 4:
            OLED << "/g초록"
        case 5:
            OLED << "/c청록"
        case 6:
            OLED << "/s파랑"
        case 7:
            OLED << "/b남색"
        case 8:
            OLED << "/v보라"
        case 9:
            OLED << "/m자주"
        default:
            OLED << "/w흰색"
```
- C-Style(Starlit 2~3)
  - 아래 코드는 완전한 C스타일 코드라고 하기는 어려운데, 엄밀히는 case문도 case(0){...}꼴로 적어야 하지만, 코드의 부피가 매우 커질 것을 우려해 아래와 같이 작성하는 것도 가능하도록 설계했다.
```C++
main(){
    a = int;
    "0부터 9까지의 수 입력: " >> OLED >> a << "\n";
    when(a){
        case 0:
            OLED << "/r빨강";
        case 1:
            OLED << "/o주황";
        case 2:
            OLED << "/y노랑";
        case 3:
            OLED << "/l연두";
        case 4:
            OLED << "/g초록";
        case 5:
            OLED << "/c청록";
        case 6:
            OLED << "/s파랑";
        case 7:
            OLED << "/b남색";
        case 8:
            OLED << "/v보라";
        case 9:
            OLED << "/m자주";
        default:
            OLED << "/w흰색";
    }
}
```

## 4. 반복문

- Starlit에서 반복문은 대표적으로 `while`문과 `for`문이 있다.
- Starlit에서 반복문을 탈출 관련 구문은 `break`, `continue`, `again` 등이 있다.
- 4장에서는 반복문과 반복문 탈출을 다룬다.

### 4.1. while문

- while문에는 조건을 넣을 수 있다.
- 조건이 참이면 구문을 실행하고 **다시 조건을 확인**
- 조건이 거짓이면 구문을 건너뜀.
- **다시 조건을 확인함으로써** 조건이 참일 때까지 계속 반복함.
- 예제 : 수를 입력하면 2로 계속 나눠서 반복 출력하기
  - 이를테면 256을 입력하면 128, 64, ..., 1까지 출력하고, 1/2는 0이 되므로 더이상 출력하지 않는다.
  - 각 수를 출력할 때마다 1칸씩 띄어서 출력한다.
- Pythonic Style Code
```Py
main:
    a = int                              # a를 정수로 정의
    "숫자 입력 : " >> OLED >> a << "\n"   # a값 입력
    while a:                             # a가 0이 아닐 때까지 반복
        f"{a} "                          # a값 출력
        a /= 2                           # a를 2로 나눔
```
- C-Style Code
```C++
main(){
    a = int; ///a를 정수로 정의
    "숫자 입력 : " >> OLED >> a << "\n"; ///a값 입력
    while(a){ ///a가 0이 아닐 때까지 반복
        f"{a} "; ///a값 출력
        a /= 2; ///a를 2로 나눔
    }
}
```

### 4.2. for문 - 기본형

- Starlit에서 for문은 다양하게 정의될 수 있다.
  - `for(변수 초기화,조건,변수 증감)`
- 예제 : 1부터 입력한 수까지의 합 구하기
  - 10을 입력하면 1+2+...+10의 값인 55가 출력될 것이다.
- Pythonic Style Code
```Py
main:
    n = int
    sum = 0
    "숫자 입력 : " >> OLED >> n << "\n"
    for i=0, i<=n, i+=1:
        sum += i
    OLED << f"1부터 {n}까지의 합은 {sum}입니다."
```
- C-Style Code
```C++
main(){
    n = int;
    sum = 0;
    "숫자 입력 : " >> OLED >> n << "\n";
    for(i=0, i<=n, i+=1){
        sum += i;
    }
    OLED << f"1부터 {n}까지의 합은 {sum}입니다.";
}
```
- C/C++에서의 for문처럼 시작값, 조건, 증감 형태로 작성하면 된다. 하지만 구분자는 `;`가 아닌 `,`를 사용한다는 점을 알 수 있다.
  - `;`를 구분자로 사용해도 무방하지만, 이런 경우 `for(i=0;i<=n;i++)`와 같이 써 주어야 한다.

### 4.3. for문 - 변형1

- for문은 간단히 아래와 같이 작성해도 상관없다. 물론 순차적인 for문에만 적용되는 한정적 규칙이다.
  - `for(변수)from(시작)to(끝)`
- Pythonic Style Code
```Py
main:
    n = int
    sum = 0
    "숫자 입력 : " >> OLED >> n << "\n"
    for i from 0 to n
        sum += i
    OLED << f"1부터 {n}까지의 합은 {sum}입니다."
```
- C-Style Code
```C++
main(){
    n = int;
    sum = 0;
    "숫자 입력 : " >> OLED >> n << "\n";
    for(i)from(0)to(n){
        sum += i;
    }
    OLED << f"1부터 {n}까지의 합은 {sum}입니다.";
}
```
- 그러나 한정적인 규칙이기도 하고, 이것보다 더 간단한 형태의 for문이 등장하는 바람에 잘 쓰지 않는 구문이 되어 버렸다.

### 4.4. for문 - 변형2

- for문의 matlab 느낌의 변형이다. 지금까지 설계한 for문 중에서 가장 간단한 편으로, Python보다 더 간단하게 느껴지는 형태이다.
  - `for(변수:시작:끝)`
  - `for(변수:시작:변화:끝)`
- Pythonic Style Code
```Py
main:
    n = int
    sum = 0
    "숫자 입력 : " >> OLED >> n << "\n"
    for i:0:n:
        sum += i
    OLED << f"1부터 {n}까지의 합은 {sum}입니다."
```
- C-Style Code
```C++
main(){
    n = int;
    sum = 0;
    "숫자 입력 : " >> OLED >> n << "\n";
    for(i:0:n){
        sum += i;
    }
    OLED << f"1부터 {n}까지의 합은 {sum}입니다.";
}
```
- 이 방식을 사용하면 홀수의 합 또는 짝수의 합도 쉽게 구해볼 수 있다. MATLAB for문 쓰듯이 작성하면 되기 때문이다.
- Pythonic Style Code
```Py
main:
    n = int
    sum = 0
    "숫자 입력 : " >> OLED >> n << "\n"
    for i:0:2:n:
        sum += i
    OLED << f"1부터 {n}까지의 짝수의 합은 {sum}입니다."
```
- C-Style Code
```C++
main(){
    n = int;
    sum = 0;
    "숫자 입력 : " >> OLED >> n << "\n";
    for(i:1:2:n){
        sum += i;
    }
    OLED << f"1부터 {n}까지의 홀수의 합은 {sum}입니다.";
}
```

### 4.5. 무한 반복 아닌 무한 반복

- 일반적으로 while(1)이라고 작성하면 무한히 반복한다.
- 그러나 반복문 내부에 break가 있으면 반복문을 탈출할 수 있다.
- 반복문 탈출을 이용해 1부터 n까지의 수 중 2의 거듭제곱(1 포함)의 합을 구하는 코드를 만들어 보자.
- Pythonic Style Code
```Py
main:
    n = int
    sum = 0
    "숫자 입력 : " >> OLED >> n << "\n"
    i = 1
    while 1:
        sum += i
        i *= 2
        if i > n: # n 초과 시 반복문 탈출
            break
    OLED << f"1부터 {n}까지의 2의 거듭제곱의 합은 {sum}입니다."
```
- C-Style Code
```C++
main(){
    n = int;
    sum = 0;
    "숫자 입력 : " >> OLED >> n << "\n";
    i = 1;
    while(1){
        sum += i;
        i *= 2;
        if(i > n){
            break;
        }
    }
    OLED << f"1부터 {n}까지의 2의 거듭제곱의 합은 {sum}입니다.";
}
```

### 4.6. Continue의 사용

- 반복문에서 Continue를 사용하면 구문을 다 실행하지 않고 반복조건으로 넘어갈 수 있다. 특히 for문의 증감은 건너뛰지 않는 특징이 있어 for문에서 자주 쓰인다.
- 아래 예제는 숫자를 입력하면 1부터 그 숫자까지 출력한다. 단, 4와 13은 건너뛰도록 하자.
- Pythonic Style Code
```Py
main:
    n = int
    "숫자 입력 : " >> OLED >> n << "\n"
    for i:1:n:
        if i == 4 || i == 13:
            continue
        f"{i} " 
```
- C-Style Code
```C++
main(){
    n = int;
    "숫자 입력 : " >> OLED >> n << "\n";
    for(i:1:n){
        if(i == 4 || i == 13){
            continue;
        }
        f"{i} ";
    }
}
```

## 5. 자료형과 연산자

### 5.1. 정수형 `int`

- 지금까지 사용한 모든 변수는 정수형 변수만 사용했다.
- 변수의 선언 : `a = int`와 같이 작성하면 변수 값 초기화 없이 선언만 할 수 있다.
- 값 초기화 진행 : `a = 0`과 같이 정수 초기값을 이용해 초기화한 상태로 정의할 수 있다.
- 지원되는 연산 : 사칙연산, 비트 Shift 연산, 비트 논리 연산, 일반 논리 연산, 비교 연산 등
  - 사칙연산 : 흔히 알려진 덧셈`+`, 뺄셈`-`, 곱셈`*`, 나눗셈`/`과 나머지 연산`%`, 지수 연산`^^`을 의미한다.
    - 나눗셈과 나머지 : 음수의 나눗셈 이슈를 해결한 형태로 `//`와 `%%` 연산자가 존재한다. 이로 인해 `//`를 주석으로 사용하지 않는다.
    - 우선순위 : 지수 > 곱셈/나눗셈/나머지 > 덧셈/뺄셈
  - 비트 Shift 연산 : 자료의 비트 기준으로 왼쪽 또는 오른쪽으로 몇 칸 이동하는 연산이다. 앞의 값은 정수, 뒤의 값은 이동할 칸 수를 적으면 된다. ~~음수는 사용하지 않는다.~~
  - 비트 논리 연산 : 동일한 위치의 비트에 대해 AND`&`, OR`|`, NOT`~`, XOR`^` 연산을 진행하는 연산
    - 우선순위 : NOT(단항 연산자) > AND > XOR > OR
  - 논리 연산 : 0이면 FALSE, 0이 아닌 경우 TRUE일 때 연산, AND`&&`, OR`||`, NOT`!`이 있다.
    - 우선순위 : NOT(단항 연산자) > AND > OR
  - 비교 연산 : 두 정수를 비교하는 연산이다. 부등호보다 등호가 우선순위가 높으며, 일반 연산자보다는 비교 연산이 우선순위가 낮으므로 등호를 사용할 때는 괄호를 사용할 필요가 없다.
    - 같다`==` / 같지 않다`!=` / 크다`>` / 크거나 같다`>=` / 작다`<` / 작거나 같다`<=`

### 5.2. 소수형(부동소수점형) `float`

- 유효숫자가 대략적으로 6자리인 소수 자료형
- 변수의 선언 : `a = float`와 같은 형태로 선언할 수 있다.
- 초기화 : `a = 0.00`과 같이 소숫점을 포함하여 정의하면 float형으로 정의된다.
- 지원되는 연산 : 사칙연산, 비교연산
  - 사칙연산 : 나머지 연산은 지원되지 않으며, 나눗셈 연산 결과가 정수가 아닌 소수가 된다.
    - 1/3의 경우 정수끼리 나누면 0이 나오지만, 소수가 적어도 하나 들어가면 0이 아니라 0.333...이 나온다.
  - 비교연산 : 정수와 소수를 섞어서 비교하는 경우 소수 기준으로 비교 결과가 나온다.
    - 이를테면 4/3과 1.023을 비교하는 경우 겉보기에는 4/3이 더 커 보이지만, 정수 4를 정수 3으로 나눈 것이므로 1과 1.023이 비교되어 오른쪽이 큰 것으로 판단한다. 만약 정수 기준으로 비교하면 같은 것으로 판단한다.

### 5.3. 자동 형변환

- 아래와 같이 코드를 작성하면 출력이 어떻게 되는지 관찰해 보자.
```Py
f"{10.23+20}"
```
- 결과는 30.23이 나온다. 그 이유는 `float`형 값 10.23과 `int`형 값 20이 덧셈을 진행하는 과정에서 자동 형변환이 일어나 20이 20.00이라는 소수로 변환되어 10.23과 20.00의 합으로 계산했기 때문이다.
- 이처럼 자동 형변환 우선순위가 정의되어 있는데, 아래와 같다.
  - `complex_t` > `float` > `int` > `byte`

### 5.4. 복소수형 `complex_t`

- `j`를 `sqrt(-1)`로 정의해 놓고 실수부와 허수부로 나누어 정의한 자료형이다.
  - 프로그래밍 언어계에서는 i가 index로 사용되는 탓에 허수단위는 `j`를 많이 사용한다.
- 선언 : `a = complex_t`
- 초기화 : `a = j * 0.00`과 같이 j를 포함한 연산이면 바로 초기화할 수 있다.
- 예제 : 복소수의 연산
```Py
f"{10.23 + j * 20:j}"
```
- 이 예제에서는 10.23은 복소수형으로 변환되고, 20 역시 소수->복소수로 변환돼서 값을 계산한다.

### 5.5. 강제 형변환

```Py
f"{sqrt(-1)}"
f"{sqrt(complex_t(-1)):j}"
```

- 이 예제에서 sqrt(-1)은 -1을 소수형으로까지만 자동 형변환해서 결과를 출력하기 때문에 결과는 NaN이 나오게 된다. 왜냐하면 sqrt(-1)은 소수형에서는 유효하지 않기 때문이다. 하지만, 복소수형으로 강제 형변환시켜서 넣으면 유효해진다.
- 강제 형변환은 Python에서의 방법처럼 진행하면 된다.
  - `int(값)` / `float(값)` / `complex_t(값)`



## 6. 함수
- 수학에서의 함수는 입력 값에 따라 출력 값이 하나로 결정되는 것을 의미한다.
- 프로그램에서의 함수는 입력 값에 따라 출력 값이 하나로 결정될 수도 있지만, 출력 없이 진행할 수도 있고, 입력이 없을수도 있고, 부수 효과가 추가될 수도 있다.
- 부수 효과는 함수 실행으로 인해 전역 변수에 해당되는 파라미터가 변하는 것을 의미하며, 쉽게 말해서 아두이노에서 출력 없는 함수 digitalWrite라는 함수를 실행했더니 LED가 켜진다면 그것이 부수 효과가 된다.
- Python에서는 값이 2개 출력되는 함수도 있지만, 엄연히 따지면 하나의 벡터를 출력하는 것이므로 함수의 정의에 부합하다. 다만, Starlit에서는 이런 방식으로 출력하는 기능은 없다.
- 함수의 입력 역시 2개 이상 넣을 수 있으며, 때로는 같은 이름의 함수의 인수를 가변적으로 조절할 수도 있다.
- 6장에서는 함수의 정의와 사용 위주로 살펴보기로 한다.

### 6.1. 함수의 정의 - 입력과 출력 모두 존재하지 않는 함수

- 지금까지 `main` 또는 `loop` 안에서 코드를 작성했는데, 이러한 함수를 정의한 것도 역시 입력과 출력이 모두 존재하지 않는 함수이다.
- 입력과 출력이 존재하지 않는 함수는 괄호 없이 정의할 수 있으며, 괄호 없이 실행할 수 있다!
- 아래는 변수를 1씩 늘려서 출력하는 함수를 정의하여 실행한 것이다.
```Py
v = 0
Print:
    v += 1
    f"{v} "

loop:
    Print
    Delay(1000)
```
- 아래 코드는 모두 유효하며, 앞에서의 내용과 실행 결과는 동일하다.
  ```Py
  v = 0
  Print:
      v += 1
      f"{v} "
  
  loop:
      Print
      Delay(1000)
  ```
  ```Py
  v = 0
  Print():
      v += 1
      f"{v} "
  
  loop:
      Print
      Delay(1000)
  ```
  ```Py
  v = 0
  Print:
      v += 1
      f"{v} "
  
  loop:
      Print()
      Delay(1000)
  ```
  ```Py
  v = 0
  Print():
      v += 1
      f"{v} "
  
  loop:
      Print()
      Delay(1000)
  ```
- C-Style에서의 함수 정의 방법은 아래와 같다.
```C++
v = 0;
Print(){
    v += 1;
    f"{v} ";
}

loop(){
    Print();
    Delay(1000);
}
```
- C-Style에서도 괄호를 생략해도 되지만, 일반적으로 넣어 준다.

### 6.2. 함수의 정의 : 출력 없이 입력만 있는 함수

- 출력 없이 입력만 있는 함수라면 대표적으로 OLED에 값을 넣어줄테니 출력해라 하는 함수를 들 수 있다.
  - 값을 반환하는 것이 아니기 때문에 출력이 없는 함수이다.
- 두 수를 넣어 합을 출력하는 코드 예제
  - 매개변수를 표시할 때는 `a:int`와 같이 자료형을 반드시 명시해야 한다. Python과 다르게 자료형이 중요하기 때문이다.
- Pythonic Style Code
```Py
PrintSum(a:int, b:int):
    f"{a+b} "

main:
    PrintSum(20, 1023)
```
- C-Style Code
```C++
PrintSum(a:int, b:int){
    f"{a+b} ";
}

main(){
    PrintSum(20, 1023);
}
```
- 출력이 없는 함수를 실행할 때는 괄호를 생략해도 된다.

- Pythonic Style Code
```Py
PrintSum(a:int, b:int):
    f"{a+b} "

main:
    PrintSum 20, 1023
```
- C-Style Code
```C++
PrintSum(a:int, b:int){
    f"{a+b} ";
}

main(){
    PrintSum 20, 1023;
}
```
## 6.3. 출력이 있는 함수
- 출력이 있는 함수는 `func():int`와 같은 형태로 함수 뒷부분에 자료형을 명시한다.
- 아래 예제는 두 수를 입력받아서 그 사이에 있는 정수들의 합을 구하는 함수이다.
- Pythonic Style Code
```Py
SumInts(a:int, b:int):int:
    sum = 0
    for i:a:b
        sum += i
    return sum

main:
    a = int
    b = int
    "a입력 - " >> OLED >> a << "\n"
    "b입력 - " >> OLED >> b << "\n"
    s = SumInts(a, b)
    f"a~b의 모든 정수의 합은 {s}입니다."
```
- C-Style Code
```C++
SumInts(a:int, b:int):int{
    sum = 0;
    for(i:a:b){
        sum += i;
    }
    return sum;
}

main(){
    a = int;
    b = int;
    "a입력 - " >> OLED >> a << "\n";
    "b입력 - " >> OLED >> b << "\n";
    s = SumInts(a, b);
    f"a~b의 모든 정수의 합은 {s}입니다.";
}
```
### 6.4. 스타일의 교차 사용
- 함수 정의는 C-Style로, main 함수는 Pythonic하게 작성해도 문제 없다.
```Py
SumInts(a:int, b:int):int{
    sum = 0;
    for(i:a:b){
        sum += i;
    }
    return sum;
}

main:
    a = int
    b = int
    "a입력 - " >> OLED >> a << "\n"
    "b입력 - " >> OLED >> b << "\n"
    s = SumInts(a, b)
    f"a~b의 모든 정수의 합은 {s}입니다."
```

## 7. 개인 취향에 맞게 스타일 사용하기

### 7.1. 한 줄로 작성하는 코드

- 2개의 변수 a, b를 정의한다고 할 때 `a = int`와 `b = int`를 두 줄에 걸쳐 사용했다. 하지만, 한 줄에 두 코드를 붙여 써도 좋다. 이때 구분자로 `;`를 사용하는 것이다.
```Py
main
    a = int; b = int
    "a입력 - " >> OLED >> a << "\n"; "b입력 - " >> OLED >> b << "\n"
    f"두 수의 합은 {a+b}입니다."
```
- C-Style에서는 극단적으로 한 줄에 모든 코드를 작성해도 문제없이 작동하기도 한다. 하지만 그렇게 좋은 방법은 아니다.
  - 이 방법은 들여쓰기 규칙이 적용되지 않는 C-Style 단독 사용에서만 유효하며, 들여쓰기 규칙을 적어도 조금이라도 적용한다면 한 줄에 모든 코드를 넣을 수 없다는 점 참고하자.
```C++
main(){a=int;b=int;"a입력 - " >> OLED >> a << "\n"; "b입력 - " >> OLED >> b << "\n";f"두 수의 합은 {a+b}입니다.";}
```

### 7.2. 특이한 함수 정의법

- 언어에는 관용 표현이 있듯이 함수에도 2개를 묶어 하나의 함수 덩어리로 정의하는 것이 가능하다. 이를테면 아래와 같은 코드이다.
```Py
AddFrom(x:int)to(y:int):int:
    sum = 0
    for i:x:y
        sum += i
    return sum

main:
    a = int
    b = int
    "a입력 - " >> OLED >> a << "\n"
    "b입력 - " >> OLED >> b << "\n"
    s = AddFrom(a)to(b)
    f"a~b의 모든 정수의 합은 {s}입니다."
```
- 여담이지만 이런 방식으로 정의하는 함수 중에서 출력이 없는 경우에 한해서 괄호를 생략하고 띄어쓰기로 대체 가능하다.
  - 이를테면 `Print(x)to(OLED)`라는 구문은 `Print x to OLED`처럼 써도 된다!

### 7.3. C-Style에서 중괄호 생략하기
- C언어에서는 조건문(switch제외)이나 반복문에서는 첫 구문에 한해서 중괄호를 생략하기도 했다. 물론 보기 좋게 하기 위해 한칸 들여쓰는 암묵적 룰이 하나 더 있었지만.
- Starlit에서도 이런 형태로 작성해도 좋다! 하지만, C와 다르게 들여쓰기 규칙이 실제로 적용된다.
- 아래와 같은 코드는 유효하다.
```C++
if(a == 20)
    OLED.Print("Twenty!");
```
- 하지만, 아래와 같은 코드는 if문이 무효화되니 주의하자.
```C++
if(a == 20)
OLED.Print("Twenty!");
```
- 앞에서 다룬 예제에서 if문에 중괄호를 생략한 코드는 아래와 같다.
```C++
SumInts(a:int, b:int):int{
    sum = 0;
    for(i:a:b)
        sum += i;
    return sum;
}

main(){
    a = int;
    b = int;
    "a입력 - " >> OLED >> a << "\n";
    "b입력 - " >> OLED >> b << "\n";
    s = SumInts(a, b);
    f"a~b의 모든 정수의 합은 {s}입니다.";
}
```
- 원래 C-Style에서 when-case문을 사용할 때 when문 안에서도 중괄호를 써야 하고, case문 안에서도 중괄호를 써야 한다(이때, `:`는 쓰지 않고 `case(4){...}`꼴로 쓴다.). 하지만, C-Style에서 중괄호 생략 기법에 의해 중괄호 없이 C에서 썼던 대로 적으면 된다. 하지만, 들여쓰기 규칙에 유의해야 한다. 즉, case를 쓴 위치보다 더 안쪽으로 들여써야 유효하다.

### 7.4. 한 줄 조건/반복문

- `for(i:a:b): sum += i;` 같은 스타일도 허용된다. 이때, `:` 뒤에는 한 칸 띄워준다.
  - 구분자를 쓰면 한 줄에 여러 코드도 실행할 수 있으므로 2개 이상의 코드를 작성할 수 있다.
  - 이렇게 작성하는 경우 여러 줄에 걸쳐서 작성하면 오작동하니 반드시 1줄에 작성한다.
- 이 방식은 간단한 `when`...`case`문에 쓰기 매우 좋다.
```C++
SumInts(a:int, b:int):int{
    sum = 0;
    for(i:a:b): sum += i;
    return sum;
}

main(){
    a = int;
    b = int;
    "a입력 - " >> OLED >> a << "\n";
    "b입력 - " >> OLED >> b << "\n";
    s = SumInts(a, b);
    f"a~b의 모든 정수의 합은 {s}입니다.";
}
```

### 7.5. 취향에 맞는 실행 함수 사용
- Starlit 언어는 원칙상 `main`함수에서 출발한다. 하지만, 취향에 맞는 프로그래밍을 지향하므로 꼭 main에서 시작해야 한다는 법은 없다. Arduino처럼 `setup`...`loop` 방식을 써도 된다. 또, `start`로 시작해도 된다. GUE Style에서 `start>>`로 시작하는데, 사실은 start라는 함수를 불러오는 것에 불과하다.
- 함수 밖에서 작성한 코드 : 그 어떤 함수보다도 가장 먼저 실행되는 코드로, 일반적으로는 변수 초기화 코드에만 적용되지만, 가끔씩은 OLED 출력과 같은 함수가 실행되기도 한다. 혹은, 특정 함수를 실행하게 해서 그 함수를 정의해야 프로그램이 돌아가게 만들 수도 있다.
- `main` : 가장 기본적인 형태로, main이 없어도 프로그램이 돌아가긴 한다. 다만, main이 없으면 함수 밖에서 실행하는 변수 초기화 기능의 코드만 실행하고 프로그램이 곧바로 종료된다. 물론 함수 밖에만 OLED 출력 코드 같은거 적으면 OLED에 출력은 된다.
- `setup`...`loop` : 프로그램이 실행되었을 때 딱 한번만 setup이 실행되고, 그 다음은 loop가 실행되는 방식이다. Arduino에서의 방식을 그대로 들여온 것이며, loop가 함수로 정의되는 특성상 필연적으로 전역 변수를 남발하는 문제점이 존재한다.
  - Starlit 5에서는 이런 이슈를 최소화하기 위해 static 전역변수 기능 추가 검토 중에 있다.

